# MAC Address Collector - Database Concept

## Architecture

Two independent data collection processes, different SNMP OIDs, different tables:

```
Process 1: Core Switch (192.168.1.1)        Process 2: Access Switches (all others)
ARP table (ipNetToMediaTable)                  FDB table (dot1dTpFdbAddress + community@vlan)
    |                                              |
    v                                              v
+------------+     +---------------+         +-------------+     +---------------+
| arp_core   | --> | arp_changes   |         | mac_current | --> | mac_changes   |
| (current)  |     | (partitioned) |         | (current)   |     | (partitioned) |
+------------+     +---------------+         +-------------+     +---------------+
```

## Primary Keys: UUID v7

All tables use **UUID v7** (RFC 9562) as primary key. UUID v7 is time-ordered,
which preserves B-tree index locality (unlike random UUID v4).

**Generated application-side** in Python 3.14+:
```python
import uuid
row_id = uuid.uuid7()  # time-ordered, monotonic within millisecond
```

No PostgreSQL extensions required. The `id` column is `UUID PRIMARY KEY`
without a DEFAULT â€” the application always provides the value on INSERT.

## Tables

### `switches` - registry of polled switches

Stores which switches to poll and whether they are core (ARP) or regular (FDB).

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | **PK**, generated by Python `uuid.uuid7()` |
| ip_address | INET | **UNIQUE** |
| hostname | TEXT | Human-readable name |
| is_core | BOOLEAN | `true` for core switch (ARP process) |
| enabled | BOOLEAN | Whether to poll this switch |

### `arp_core` - current ARP state (core switch only)

One row per unique MAC address. Updated via upsert on every poll cycle.

Fields use **PostgreSQL arrays** (`INET[]`, `INTEGER[]`, `TEXT[]`) because in case
of network loops or multi-homing, a single MAC can have multiple IPs, VLANs,
and interfaces simultaneously.

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | **PK**, generated by Python `uuid.uuid7()` |
| mac_address | MACADDR | **UNIQUE** - the only constraint |
| ip_addresses | INET[] | All IPs associated with this MAC (sorted) |
| vlan_ids | INTEGER[] | All VLANs where this MAC is seen (sorted) |
| interfaces | TEXT[] | All interfaces where this MAC is seen (sorted) |
| topology_hash | TEXT | MD5 of sorted arrays - fast change detection |
| first_seen | TIMESTAMPTZ | When this MAC was first observed |
| last_seen | TIMESTAMPTZ | Last poll that saw this MAC |
| poll_count | INTEGER | Total number of polls that observed this MAC |

### `arp_changes` - ARP change log (weekly partitions)

Written **only when something changes** (detected via `topology_hash` mismatch).
Each row is a snapshot of the MAC's state at the moment of change.

Inherits all data fields from `arp_core` plus:

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Generated by Python `uuid.uuid7()` |
| change_flags | SMALLINT | Bitmask indicating what changed |
| changed_at | TIMESTAMPTZ | When the change was detected |

**UNIQUE constraint:** `(mac_address, changed_at)`

### `mac_current` - current FDB state (access switches)

One row per unique MAC address across all access switches.

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | **PK**, generated by Python `uuid.uuid7()` |
| mac_address | MACADDR | **UNIQUE** - the only constraint |
| switch_ips | INET[] | All switch IPs where this MAC is seen (sorted) |
| vlan_ids | INTEGER[] | All VLANs (sorted) |
| interfaces | TEXT[] | All interfaces (sorted) |
| topology_hash | TEXT | MD5 of sorted arrays |
| first_seen | TIMESTAMPTZ | First observation |
| last_seen | TIMESTAMPTZ | Last observation |
| poll_count | INTEGER | Poll count |

### `mac_changes` - FDB change log (weekly partitions)

Same logic as `arp_changes`. Inherits data fields from `mac_current` plus:

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Generated by Python `uuid.uuid7()` |
| change_flags | SMALLINT | Bitmask indicating what changed |
| changed_at | TIMESTAMPTZ | When the change was detected |

**UNIQUE constraint:** `(mac_address, changed_at)`

## Change Detection: Bitmask (`change_flags`)

Inspired by Linux file permission bits (rwx = 4+2+1):

### `arp_changes`

| Bit | Value | Meaning |
|-----|-------|---------|
| r | 4 | `ip_addresses` changed |
| w | 2 | `vlan_ids` changed |
| x | 1 | `interfaces` changed |

### `mac_changes`

| Bit | Value | Meaning |
|-----|-------|---------|
| r | 4 | `switch_ips` changed |
| w | 2 | `vlan_ids` changed |
| x | 1 | `interfaces` changed |

### Examples

| change_flags | Binary | What changed |
|--------------|--------|--------------|
| 7 | 111 | Everything changed (IP/switch + VLAN + interface) |
| 6 | 110 | IP/switch + VLAN changed |
| 5 | 101 | IP/switch + interface changed |
| 4 | 100 | Only IP/switch changed |
| 3 | 011 | VLAN + interface changed |
| 2 | 010 | Only VLAN changed |
| 1 | 001 | Only interface changed |

## Change Detection: `topology_hash`

Each `*_current` table has a `topology_hash` column - MD5 hash of the sorted,
concatenated array values. This enables O(1) change detection:

```
new_hash = MD5(sorted(ips)::text || sorted(vlans)::text || sorted(ifaces)::text)

if new_hash == old_hash:
    # No change, just update last_seen and poll_count
else:
    # Something changed:
    # 1. Compare individual arrays to compute change_flags
    # 2. INSERT snapshot into *_changes with change_flags
    # 3. UPDATE *_current with new values and new hash
```

## Partitioning Strategy

Both `*_changes` tables use PostgreSQL **declarative range partitioning**
on the `changed_at` column, with one partition per week.

- Partition naming: `arp_changes_YYYY_wWW` / `mac_changes_YYYY_wWW`
- Auto-creation: function `create_weekly_partitions(table_name, weeks_ahead)`
  creates partitions N weeks into the future
- **No data deletion.** Partitions are never dropped.
- Partitioning benefits: fast queries by time range, easy backup of old data,
  no overhead from scanning decades of history for recent queries

## Data Retention

**No deletion policy.** All historical data is preserved indefinitely.
Partitioning keeps queries fast regardless of total data volume.

## Handling Network Loops

When a loop occurs, a MAC address appears on multiple switches/VLANs/interfaces
simultaneously. The array-based schema handles this naturally:

```
mac_current row for AA:BB:CC:DD:EE:FF during a loop:
  switch_ips:  {192.168.1.15, 192.168.1.200}
  vlan_ids:    {100, 200}
  interfaces:  {Gi1/0/5, Gi2/0/10}
```

When the loop is resolved, the next poll detects the topology_hash change,
logs the transition in `mac_changes` (with appropriate change_flags),
and updates `mac_current` to reflect the new single-location state.
