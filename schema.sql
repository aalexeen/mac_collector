-- MAC Address Collector â€” PostgreSQL Schema
-- Run: psql -U mac_collector_user -d mac_collector -f schema.sql
--
-- UUID v7: generated application-side in Python (uuid_utils)
-- No PostgreSQL extensions required.

BEGIN;

-- ============================================================
-- Registry of switches to poll
-- ============================================================
CREATE TABLE IF NOT EXISTS switches (
    id          UUID PRIMARY KEY,  -- generated by Python uuid.uuid7()
    ip_address  INET NOT NULL UNIQUE,
    hostname    TEXT,
    is_core     BOOLEAN NOT NULL DEFAULT false,
    enabled     BOOLEAN NOT NULL DEFAULT true
);

-- ============================================================
-- Process 1: Core switch ARP table (192.168.1.1)
-- ============================================================

-- Current state: one row per MAC, arrays for multi-value fields
CREATE TABLE IF NOT EXISTS arp_core (
    id              UUID PRIMARY KEY,  -- generated by Python uuid.uuid7()
    mac_address     MACADDR NOT NULL UNIQUE,
    ip_addresses    INET[] NOT NULL DEFAULT '{}',
    vlan_ids        INTEGER[] NOT NULL DEFAULT '{}',
    interfaces      TEXT[] NOT NULL DEFAULT '{}',
    topology_hash   TEXT NOT NULL DEFAULT '',
    first_seen      TIMESTAMPTZ NOT NULL DEFAULT now(),
    last_seen       TIMESTAMPTZ NOT NULL DEFAULT now(),
    poll_count      INTEGER NOT NULL DEFAULT 1
);

CREATE INDEX IF NOT EXISTS idx_arp_core_mac      ON arp_core(mac_address);
CREATE INDEX IF NOT EXISTS idx_arp_core_last_seen ON arp_core(last_seen);
CREATE INDEX IF NOT EXISTS idx_arp_core_ip       ON arp_core USING GIN(ip_addresses);

-- Change log: partitioned by week, never deleted
-- change_flags bitmask: IP=4, VLAN=2, interface=1
CREATE TABLE IF NOT EXISTS arp_changes (
    id              UUID,  -- generated by Python uuid.uuid7()
    mac_address     MACADDR NOT NULL,
    ip_addresses    INET[] NOT NULL DEFAULT '{}',
    vlan_ids        INTEGER[] NOT NULL DEFAULT '{}',
    interfaces      TEXT[] NOT NULL DEFAULT '{}',
    change_flags    SMALLINT NOT NULL,
    changed_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE (mac_address, changed_at)
) PARTITION BY RANGE (changed_at);

CREATE INDEX IF NOT EXISTS idx_arp_changes_mac   ON arp_changes(mac_address);
CREATE INDEX IF NOT EXISTS idx_arp_changes_flags ON arp_changes(change_flags);

-- ============================================================
-- Process 2: Access switches FDB table
-- ============================================================

-- Current state: one row per MAC across all switches
CREATE TABLE IF NOT EXISTS mac_current (
    id              UUID PRIMARY KEY,  -- generated by Python uuid.uuid7()
    mac_address     MACADDR NOT NULL UNIQUE,
    switch_ips      INET[] NOT NULL DEFAULT '{}',
    vlan_ids        INTEGER[] NOT NULL DEFAULT '{}',
    interfaces      TEXT[] NOT NULL DEFAULT '{}',
    topology_hash   TEXT NOT NULL DEFAULT '',
    first_seen      TIMESTAMPTZ NOT NULL DEFAULT now(),
    last_seen       TIMESTAMPTZ NOT NULL DEFAULT now(),
    poll_count      INTEGER NOT NULL DEFAULT 1
);

CREATE INDEX IF NOT EXISTS idx_mac_current_mac      ON mac_current(mac_address);
CREATE INDEX IF NOT EXISTS idx_mac_current_last_seen ON mac_current(last_seen);
CREATE INDEX IF NOT EXISTS idx_mac_current_switch   ON mac_current USING GIN(switch_ips);

-- Change log: partitioned by week, never deleted
-- change_flags bitmask: switch_ip=4, VLAN=2, interface=1
CREATE TABLE IF NOT EXISTS mac_changes (
    id              UUID,  -- generated by Python uuid.uuid7()
    mac_address     MACADDR NOT NULL,
    switch_ips      INET[] NOT NULL DEFAULT '{}',
    vlan_ids        INTEGER[] NOT NULL DEFAULT '{}',
    interfaces      TEXT[] NOT NULL DEFAULT '{}',
    change_flags    SMALLINT NOT NULL,
    changed_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE (mac_address, changed_at)
) PARTITION BY RANGE (changed_at);

CREATE INDEX IF NOT EXISTS idx_mac_changes_mac   ON mac_changes(mac_address);
CREATE INDEX IF NOT EXISTS idx_mac_changes_flags ON mac_changes(change_flags);

-- ============================================================
-- Users
-- ============================================================
CREATE TABLE IF NOT EXISTS users (
    id            UUID        PRIMARY KEY,        -- _uuid7() from Python
    email         TEXT        NOT NULL UNIQUE,
    password_hash TEXT        NOT NULL,           -- bcrypt (passlib)
    role          TEXT        NOT NULL
                              CHECK (role IN ('admin', 'operator', 'viewer')),
    enabled       BOOLEAN     NOT NULL DEFAULT true,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_users_email   ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_enabled ON users(enabled) WHERE enabled = true;

-- ============================================================
-- Audit log (partitioned by week)
-- ============================================================
CREATE TABLE IF NOT EXISTS audit_log (
    id           UUID,                            -- _uuid7() from Python
    user_id      UUID        REFERENCES users(id) ON DELETE RESTRICT,
    -- user_id NULL is valid for login_failed (user may not exist)
    action       TEXT        NOT NULL,
    detail       JSONB       NOT NULL DEFAULT '{}',
    ip_address   INET        NOT NULL,
    logged_at    TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY RANGE (logged_at);

CREATE INDEX IF NOT EXISTS idx_audit_log_user_id   ON audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_action    ON audit_log(action);
CREATE INDEX IF NOT EXISTS idx_audit_log_logged_at ON audit_log(logged_at DESC);

-- ============================================================
-- Function: auto-create weekly partitions
-- ============================================================
CREATE OR REPLACE FUNCTION create_weekly_partitions(
    p_table_name TEXT,
    p_weeks_ahead INTEGER DEFAULT 4
)
RETURNS INTEGER AS $$
DECLARE
    v_start DATE;
    v_end DATE;
    v_partition_name TEXT;
    v_created INTEGER := 0;
    v_week_start DATE;
    v_year INTEGER;
    v_week INTEGER;
BEGIN
    -- Start from current week's Monday
    v_week_start := date_trunc('week', CURRENT_DATE)::DATE;

    FOR i IN 0..p_weeks_ahead LOOP
        v_start := v_week_start + (i * INTERVAL '1 week');
        v_end := v_start + INTERVAL '1 week';
        v_year := EXTRACT(ISOYEAR FROM v_start);
        v_week := EXTRACT(WEEK FROM v_start);

        v_partition_name := format('%s_%s_w%s',
            p_table_name,
            v_year,
            lpad(v_week::TEXT, 2, '0')
        );

        -- Skip if partition already exists
        IF NOT EXISTS (
            SELECT 1 FROM pg_class WHERE relname = v_partition_name
        ) THEN
            EXECUTE format(
                'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                v_partition_name,
                p_table_name,
                v_start,
                v_end
            );
            v_created := v_created + 1;
        END IF;
    END LOOP;

    RETURN v_created;
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- Collection log: one row per switch per poll run
-- ============================================================
CREATE TABLE IF NOT EXISTS collection_log (
    id           UUID,                            -- _uuid7() from Python
    polled_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
    collector    TEXT        NOT NULL,             -- 'fdb' | 'arp'
    switch_ip    INET        NOT NULL,
    duration_ms  INT,                             -- SNMP poll wall-clock time
    macs_total   INT,                             -- entries returned by collector (NULL on error)
    macs_changed INT         NOT NULL DEFAULT 0,  -- new + topology-changed MACs
    macs_gone    INT         NOT NULL DEFAULT 0,  -- MACs that disappeared (fdb only)
    error        TEXT                             -- NULL = success
) PARTITION BY RANGE (polled_at);

CREATE INDEX IF NOT EXISTS idx_collection_log_polled_at ON collection_log(polled_at DESC);
CREATE INDEX IF NOT EXISTS idx_collection_log_switch_ip ON collection_log(switch_ip);
CREATE INDEX IF NOT EXISTS idx_collection_log_error     ON collection_log(error)
    WHERE error IS NOT NULL;

-- ============================================================
-- Create initial partitions (current week + 4 weeks ahead)
-- ============================================================
SELECT create_weekly_partitions('arp_changes',     4);
SELECT create_weekly_partitions('mac_changes',     4);
SELECT create_weekly_partitions('audit_log',       4);
SELECT create_weekly_partitions('collection_log',  4);

-- ============================================================
-- Seed core switch
-- ============================================================
INSERT INTO switches (id, ip_address, hostname, is_core, enabled)
VALUES (gen_random_uuid(), '192.168.1.1', 'sw-core-01', true, true)
ON CONFLICT (ip_address) DO NOTHING;

COMMIT;
